#!/bin/sh

# secure_path - This is a best-effort attempt to check for security issues in
# $PATH and remove the problematic directories. It definitely won't catch
# everything.
#
# USAGE:
#   secure_path                    # Output cleaned PATH to stdout
#   export PATH="$(secure_path)"   # Set PATH to cleaned version
#
# SECURITY CHECKS:
#   - Removes relative paths (paths not starting with /)
#   - Removes non-existent directories
#   - Removes directories owned by untrusted users
#   - Removes world-writable directories with world-executable ancestors
#   - Removes empty directories that are world-deletable
#   - Validates directory permissions format
#
# TRUSTED USERS:
#   By default, only directories owned by you or root (uid 0) are trusted.
#   To trust additional users, add their username or uid to:
#   $DOTFILES/trusted_users.txt (one per line)
#
# NOTES:
#   - Prints messages to stderr in some cases
#   - Appends system default PATH from getconf PATH
#   - Deduplicates the final PATH
#   - Falls back to original PATH if result would be empty

orig_path="$PATH"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin"
system_path_good=
if system_path="$(getconf PATH)" && [ -n "$system_path" ]; then
	system_path_good=1
	export PATH="${system_path}:$PATH"
fi

export LC_ALL=C

newline='
'

stat=stat

# detect stat flavor
stattype=""
if command -v stat >/dev/null 2>&1; then
	# try BSD stat style
	if $stat -f '%Sp %u' / >/dev/null 2>&1; then
		stattype=bsd
	# try GNU stat style
	elif $stat -c '%A %u' / >/dev/null 2>&1; then
		stattype=gnu
	fi
fi

follow=
stat_maybe_follow_symlinks() {
	if [ "$follow" = "follow" ]; then
		$stat -L "$@"
	else
		$stat "$@"
	fi
}

ls_maybe_follow_symlinks() {
	if [ "$follow" = "follow" ]; then
		ls -L "$@"
	else
		ls "$@"
	fi
}

# get perms for a single path (symbolic perms like drwxr-xr-x)
get_perms_and_uid() {
	case "$stattype" in
		bsd)
			stat_maybe_follow_symlinks -f '%Sp %u' -- "$@"
			;;
		gnu)
			stat_maybe_follow_symlinks -c '%A %u' -- "$@"
			;;
		*)
			# ls fallback: loop per-arg to avoid relying on any particular ls behaviour for multiple args
			for f in "$@"; do
				# -l: long, -n: numeric ids, -d: directory entry itself
				line="$(ls_maybe_follow_symlinks -lnd -- "$f")"
				if [ -z "$line" ]; then
					# keep a placeholder that will fail check_perms_format
					printf '??????????? 99999999\n'
				else
					# typical ls -ln output: perms links uid gid size date name
					# we want perms and numeric uid (field 1 and 3)
					# awk is safe here because owner and group are numeric with -n
					printf '%s %s\n' "$(printf '%s' "$line" | awk '{print $1}')" "$(printf '%s' "$line" | awk '{print $3}')"
				fi
			done
			;;
	esac
}

check_perms_format() {
	case "$1" in
		?[r-][w-][Ssx-][r-][w-][Ssx-][r-][w-][Ttx-]*) return 0 ;;
		*) return 1 ;;
	esac
}

is_writable_and_not_sticky() {
	case "$(follow=follow get_perms_and_uid "$1")" in
		#rwxrwxrwx
		????????wx*) return 0 ;;
		*) return 1 ;;
	esac
}

is_other_executable() {
	case "$(follow=follow get_perms_and_uid "$1")" in
		#rwxrwxrwx
		?????????[-T]*) return 1 ;;
		*) return 0 ;;
	esac
}

# return true (0) if all ancestors are o+x
# return false (1) if any ancestor isn't o+x
can_world_reach() {
	dir1="$1"
	while [ "$dir1" != "/" ]; do
		perms1="$(follow=nofollow get_perms_and_uid "$dir1")"
		#o+x?
		if [ "$(printf '%s' "$perms1" | cut -c10)" = "-" ]; then
			return 1
		fi
		dir1="$(dirname "$dir1")"
	done
	return 0
}

is_dir_empty() {
	# must be a directory and readable
	[ -d "$1" ] || return 0
	[ -r "$1" ] || return 0
	# "$1"/* -> everything that doesn't start with '.'
	# "$1"/.[!.]* -> everything (except '.' itself) that starts with '.' but not '..'
	# "$1"/..?* -> everything (except '..' itself) that starts with '..'
	for entry in "$1"/* "$1"/.[!.]* "$1"/..?*; do
		# if the glob didn't match it remains a literal pattern -> -e will be false
		if [ -e "$entry" ]; then
			# found a real entry (these globs do not match '.' or '..')
			return 1 # not empty
		fi
	done
	return 0 # empty
}

IFS=':'
for dir in $orig_path; do
	if [ "${dir#/}" = "$dir" ]; then
		>&2 echo "removing '$dir' because doesn't start with /"
		continue
	fi

	[ -d "$dir" ] || {
		# >&2 echo "removing '$dir' because it's not an existing directory"
		continue
	}

	set -- "$@" "$dir"
done

all_perms_and_uids="$(follow=follow get_perms_and_uid "$@")"

my_user="$(id -u)"
if [ "$my_user" = 0 ]; then
	my_user="${SUDO_UID:-$(id -u "$(logname)")}"
fi
if [ -z "$my_user" ]; then
	my_user=0
fi

IFS="$newline"
if command -v realpath >/dev/null 2>&1; then
	# shellcheck disable=SC2046 # intentionally word-splitting
	set -- $(realpath -- "$@")
fi

trusted_users_file="$DOTFILES/trusted_users.txt"
trusted_users="$(cat "$trusted_users_file" 2>/dev/null)"

ret=''
IFS="$newline"
for perms in $all_perms_and_uids; do
	dir="$1"
	shift

	if [ "${dir#/}" = "$dir" ]; then
		>&2 echo "removing '$dir' because doesn't start with /"
		continue
	fi

	[ -d "$dir" ] || {
		>&2 echo "removing '$dir' because it's not an existing directory"
		continue
	}

	check_perms_format "$perms" || {
		>&2 echo "removing '$dir' because invalid permissions: $perms"
		continue
	}

	# remove everything before (and including) the space
	owner="${perms#* }"
	if [ "$owner" != "$my_user" ] && [ "$owner" != "0" ]; then
		case "$newline$trusted_users$newline" in
			"$newline$owner$newline")
				;;
			"$newline$(id -un "$owner")$newline")
				;;
			*)
				>&2 echo "removing '$dir' because owned by untrusted user: '$(id -un "$owner")' ($owner); if you trust them, add the username or uid to $trusted_users_file"
				continue
				;;
		esac
	fi

	firstchar="${perms%"${perms#?}"}"
	if [ "$firstchar" != "d" ]; then
		>&2 echo "This shouldn't happen: firstchar='$firstchar': $dir"
		continue
	fi

	case "$perms" in
		????????w?*)
			if can_world_reach "$dir"; then
				>&2 echo "removing '$dir' because world writable (o+w, and its ancestors are o+x)"
				continue
			fi
			;;
	esac

	if is_dir_empty "$dir" && is_writable_and_not_sticky "$(dirname "$dir")" && can_world_reach "$dir"; then
		>&2 echo "removing '$dir' because world deletable (empty, its parent is writable and not sticky, and its ancestors are o+x)"
		continue
	fi

	ret="${ret}:${dir}"
done

# Add the default system PATH back at the end
if [ -n "$system_path_good" ]; then
	ret="${ret%:}:${system_path#:}"
fi

# deduplicate
ret="$(printf '%s' ":${ret#:}:" | awk -v RS=":" -v ORS=":" '!x[$0]++')"
ret="${ret%:}"
ret="${ret#:}"

if [ -z "$ret" ]; then
	>&2 echo "WARNING: secure_path: reverting to original PATH because the new PATH is empty"
	printf '%s' "$PATH"
else
	printf '%s' "$ret"
fi

:
