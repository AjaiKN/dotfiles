#!/usr/bin/env bash

set -euo pipefail
# shellcheck disable=SC2154
trap 's=$?; echo >&2 ": Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR

if [ $# -lt 1 ]; then
	echo "Usage: git unshelve <BRANCH-NAME>..."
	echo
	cat <<-EOF
		Just like magit's magit-branch-unshelve, which is described as follows:

		> This command unshelves a branch that was previously shelved using
		> magit-branch-shelve. This is done by deleting the reference
		> "refs/shelved/BRANCH-NAME" and creating a branch "BRANCH-NAME" pointing at
		> the same commit as the deleted reference pointed at. If the deleted
		> reference had a reflog, then that is restored as the reflog of the branch.
	EOF
	exit 1
fi

for branch in "$@"; do
	branch=${branch#refs/shelved/}
	branch=${branch#shelved/}

	old=refs/shelved/"$branch"
	new=refs/heads/"$branch"
	old_abbrev=$(git rev-parse --verify --abbrev-ref "$old" 2>/dev/null) || {
		printf '%s does not exist\n' "$old" >&2
		exit 1
	}

	old_reflog="$(git rev-parse --show-toplevel)"/.git/logs/"$old"
	new_reflog="$(git rev-parse --show-toplevel)"/.git/logs/"$new"

	git update-ref "$new" "$old" ''

	# rename reflog file
	if [ -f "$old_reflog" ]; then
		mkdir -p "${new_reflog%/*}"
		mv "$old_reflog" "$new_reflog"
	fi

	git update-ref -d "$old"

	printf '%s -> %s (%s)\n' "$old_abbrev" "$(git rev-parse --abbrev-ref "$new")" "$(git rev-parse --short "$new")"
done
